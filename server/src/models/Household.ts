import mongoose, { Schema, Document, Query } from "mongoose";
import { HouseholdType, HouseholdUpdateType } from "../types/HouseholdTypes";
import { HousingTypeEnum } from "../types/HouseholdTypes";
import { EnvironmentalPracticeEnum, SurveyStatusEnum } from "../types/HouseholdTypes";
import slugify from "slugify";
import crypto from "crypto";
import { ErrorResponse } from "../middleware/error";

/**
 * Indexed fields used throughout the Household model.
 */
const indexedFields = {
  SLUG: "slug",
  FOCAL_POINT_EMAIL: "email",
} as const;

const familyMemberSchema = new Schema({
  firstName: { type: String, required: true },
  lastName: { type: String, required: true },
  birthDate: { type: Date, required: true },
});

const focalPointSchema = new Schema(
  {
    firstName: { type: String },
    pictureUrl: { type: String },
    [indexedFields.FOCAL_POINT_EMAIL]: { type: String, required: true },
  },
  { _id: false }
);

const householdSchema = new Schema(
  {
    /**
     * Autogenerated slug
     * - Used for URL generation
     * - Immutable
     */
    [indexedFields.SLUG]: {
      type: String,
      required: true,
      immutable: true,
    },
    familyName: { type: String, required: true },
    address: { type: String, required: true },
    surveyStatus: {
      type: String,
      enum: Object.values(SurveyStatusEnum),
      default: SurveyStatusEnum.PENDING,
    },
    dateSurveyed: { type: Date, default: null },
    focalPoint: { type: focalPointSchema, required: true },
    familyMembers: [familyMemberSchema],
    numberOfCars: { type: Number, min: 0 },
    hasPets: { type: Boolean },
    numberOfPets: { type: Number, min: 0 },
    housingType: {
      type: {
        value: {
          type: String,
          enum: Object.values(HousingTypeEnum),
        },
        customValue: {
          type: String,
          validate: {
            validator: function (this: any, value: string) {
              // If value is "Other", customValue is required
              if (this.value === HousingTypeEnum.OTHER) {
                return value != null && value.trim().length > 0;
              }
              // If value is not "Other", customValue should be null/undefined
              return value == null;
            },
            message: "Custom value is required when housing type is 'Other'",
          },
        },
      },
    },
    environmentalPractices: [
      {
        type: String,
        enum: Object.values(EnvironmentalPracticeEnum),
      },
    ],
  },
  {
    timestamps: true,
  }
);

/**
 * Database indexes configuration
 * - SLUG: Unique index for fast lookups by slug
 * - FOCAL_POINT_EMAIL: Index for searching households by focal point's email
 */
householdSchema.index({ [indexedFields.SLUG]: 1 }, { unique: true });
householdSchema.index({ [indexedFields.FOCAL_POINT_EMAIL]: 1 });

function generateSlug(familyName: string): string {
  // Generate the slug part using slugify with strict mode
  const slugPart = slugify(familyName, {
    lower: true,
    strict: true,
    trim: true,
  });

  // Generate a unique 6-character identifier using crypto
  const uniqueId = crypto.randomBytes(4).toString("hex").slice(0, 6);

  // Combine them with a hyphen
  return `${slugPart}-${uniqueId}`;
}

/**
 * Pre-validate hook to generate a unique slug and clean up housing type data
 */
householdSchema.pre("validate", function (next) {
  try {
  // Generate slug in the initial creation of the document
  if (!this.slug) {
    this.slug = generateSlug(this.familyName);
  }

  // Clean up housing type customValue
  if (this.housingType && this.housingType?.value !== HousingTypeEnum.OTHER) {
    // Remove customValue for non-Other types
    this.housingType.customValue = undefined;
  }

    next();
  } catch (error: any) {
    next(error);
  }
});

function validateCompletedSurvey(
  doc: Partial<HouseholdType>,
) {
  // Only validate if status is being changed to completed
  if (doc.surveyStatus === SurveyStatusEnum.COMPLETED) {
    const requiredFields = [
      "familyName",
      "address",
      "focalPoint.firstName",
      "focalPoint.email",
      "familyMembers",
      "numberOfCars",
      "hasPets",
      "housingType.value",
    ];

    const missingFields = requiredFields.filter((field) => {
      const value = field.split(".").reduce((obj: any, key) => obj?.[key], doc);
      return value === undefined || value === null || value === "";
    });

    if (missingFields.length > 0) {
      throw new ErrorResponse(`Cannot complete survey. Missing required fields: ${missingFields.join(", ")}`, 400);
    }

    // Validate family members array is not empty
    if (!doc.familyMembers || doc.familyMembers.length === 0) {
      throw new ErrorResponse("Cannot complete survey. At least one family member is required.", 400);
    }

    // Validate numberOfPets if hasPets is true
    if (doc.hasPets && (!doc.numberOfPets || doc.numberOfPets <= 0)) {
      throw new ErrorResponse("Cannot complete survey. Number of pets must be greater than 0 when hasPets is true.", 400);
    }

    // Validate housing type customValue if value is "Other"
    if (
      doc.housingType?.value === HousingTypeEnum.OTHER &&
      (!doc.housingType.customValue || doc.housingType.customValue.trim() === "")
    ) {
      throw new ErrorResponse("Cannot complete survey. Custom housing type value is required when type is 'Other'.", 400);
    }
  }
}

// Helper function to handle email updates
async function handleEmailUpdate(
  update: HouseholdUpdateType,
  isAdminUpdate: boolean,
  query: Query<any, any>,
) {
  if (update?.focalPoint?.email) {
    // Retrieve the original focal point email before change:
    const originalDoc = await HouseholdModel.findById(query.getQuery()._id as string).select(
      "focalPoint.email"
    );
    const originalFocalPointEmail = originalDoc ? originalDoc.focalPoint.email : null;

    if(originalFocalPointEmail !== update.focalPoint.email && !isAdminUpdate) {
      throw new ErrorResponse("Email can only be modified by an admin", 401);
    }
  }
}

householdSchema.pre(
  "findOneAndUpdate",
  async function (this: Query<any, any>, next: mongoose.CallbackWithoutResultAndOptionalError) {
    try {
      const update = this.getUpdate() as HouseholdUpdateType;

      const isAdminUpdate = Boolean(update.isAdminUpdate);
      delete update.isAdminUpdate;

      // Remove _id from the update object if it exists
      if (update._id) {
        delete update._id;
      }

      // Handle survey completion
      if (update.surveyStatus === SurveyStatusEnum.COMPLETED) {
        update.dateSurveyed = new Date();
      }

      // Validate survey completion if needed
      if (update.surveyStatus === SurveyStatusEnum.COMPLETED) {
        validateCompletedSurvey(update);
      }

      // Handle email update validation
      if (update?.focalPoint?.email) {
        await handleEmailUpdate(update, isAdminUpdate, this);
      }

      next();
    } catch (error: any) {
      // Ensure we pass the error to next() to properly handle it in the middleware chain
      next(error);
    }
  }
);

export const HouseholdModel = mongoose.model<HouseholdType & Document>(
  "Household",
  householdSchema
);
