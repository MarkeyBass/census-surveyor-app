import mongoose, { Schema, Document, Query } from "mongoose";
import { HouseholdType } from "../types/HouseholdTypes";
import { HousingTypeEnum } from "../types/HouseholdTypes";
import { EnvironmentalPracticeEnum, SurveyStatusEnum } from "../types/HouseholdTypes";
import slugify from "slugify";
import crypto from "crypto";

/**
 * Indexed fields used throughout the Household model.
 */
const indexedFields = {
  SLUG: "slug",
  FOCAL_POINT_EMAIL: "email",
} as const;

const familyMemberSchema = new Schema({
  firstName: { type: String, required: true },
  lastName: { type: String, required: true },
  birthDate: { type: Date, required: true },
});

const focalPointSchema = new Schema(
  {
    firstName: { type: String },
    pictureUrl: { type: String },
    [indexedFields.FOCAL_POINT_EMAIL]: { type: String, required: true },
  },
  { _id: false }
);

const householdSchema = new Schema(
  {
    // Autogenerated slug
    [indexedFields.SLUG]: { 
      type: String, 
      required: true,
      immutable: true
    },
    familyName: { type: String, required: true },
    address: { type: String, required: true },
    surveyStatus: {
      type: String,
      enum: Object.values(SurveyStatusEnum),
      default: SurveyStatusEnum.PENDING,
    },
    dateSurveyed: { type: Date },
    focalPoint: { type: focalPointSchema, required: true },
    familyMembers: [familyMemberSchema],
    numberOfCars: { type: Number, min: 0 },
    hasPets: { type: Boolean },
    numberOfPets: { type: Number, min: 0 },
    housingType: {
      type: {
        value: {
          type: String,
          enum: Object.values(HousingTypeEnum),
        },
        customValue: {
          type: String,
          validate: {
            validator: function (this: any, value: string) {
              // If value is "Other", customValue is required
              if (this.value === HousingTypeEnum.OTHER) {
                return value != null && value.trim().length > 0;
              }
              // If value is not "Other", customValue should be null/undefined
              return value == null;
            },
            message: "Custom value is required when housing type is 'Other'",
          },
        },
      },
    },
    environmentalPractices: [
      {
        type: String,
        enum: Object.values(EnvironmentalPracticeEnum),
      },
    ],
  },
  {
    timestamps: true,
    // Allow partial documents during initial creation
    // strict: false
  }
);

/**
 * Database indexes configuration
 * - SLUG: Unique index for fast lookups by slug
 * - FOCAL_POINT_EMAIL: Index for searching households by focal point's email
 */
householdSchema.index({ [indexedFields.SLUG]: 1 }, { unique: true });
householdSchema.index({ [indexedFields.FOCAL_POINT_EMAIL]: 1 });

function generateSlug(familyName: string): string {
  // Generate the slug part using slugify with strict mode
  const slugPart = slugify(familyName, { 
    lower: true,
    strict: true,
    trim: true
  });
  
  // Generate a unique 6-character identifier using crypto
  const uniqueId = crypto.randomBytes(4).toString('hex').slice(0, 6);
  
  // Combine them with a hyphen
  return `${slugPart}-${uniqueId}`;
}

/**
 * Pre-validate hook to generate a unique slug and clean up housing type data
 */
householdSchema.pre("validate", function (next) {
  // Generate slug in the initial creation of the document
  if (!this.slug) {
    this.slug = generateSlug(this.familyName);
  }

  // Clean up housing type customValue
  if (this.housingType && this.housingType?.value !== HousingTypeEnum.OTHER) {
    // Remove customValue for non-Other types
    this.housingType.customValue = undefined;
  }

  next();
});

/**
 * Pre-save hook to validate completed survey data
 * Works with both save and findByIdAndUpdate operations
 */
householdSchema.pre("save", function (this: HouseholdType & Document, next: mongoose.CallbackWithoutResultAndOptionalError) {
  validateCompletedSurvey(this, next);
});

// Use findOneAndUpdate for both findOneAndUpdate and findByIdAndUpdate
householdSchema.pre("findOneAndUpdate", function (this: Query<any, any>, next: mongoose.CallbackWithoutResultAndOptionalError) {
  const doc = this.getUpdate() as Partial<HouseholdType>;
  validateCompletedSurvey(doc, next);
});

function validateCompletedSurvey(doc: Partial<HouseholdType>, next: mongoose.CallbackWithoutResultAndOptionalError) {
  // Only validate if status is being changed to completed
  if (doc.surveyStatus === SurveyStatusEnum.COMPLETED) {
    const requiredFields = [
      "familyName",
      "address",
      "focalPoint.firstName",
      "focalPoint.email",
      "familyMembers",
      "numberOfCars",
      "hasPets",
      "housingType.value",
      "dateSurveyed"
    ];

    const missingFields = requiredFields.filter(field => {
      const value = field.split('.').reduce((obj: any, key) => obj?.[key], doc);
      return value === undefined || value === null || value === '';
    });

    if (missingFields.length > 0) {
      return next(new Error(`Cannot complete survey. Missing required fields: ${missingFields.join(', ')}`));
    }

    // Validate family members array is not empty
    if (!doc.familyMembers || doc.familyMembers.length === 0) {
      return next(new Error("Cannot complete survey. At least one family member is required."));
    }

    // Validate numberOfPets if hasPets is true
    if (doc.hasPets && (!doc.numberOfPets || doc.numberOfPets <= 0)) {
      return next(new Error("Cannot complete survey. Number of pets must be greater than 0 when hasPets is true."));
    }

    // Validate housing type customValue if value is "Other"
    if (doc.housingType?.value === HousingTypeEnum.OTHER && 
        (!doc.housingType.customValue || doc.housingType.customValue.trim() === '')) {
      return next(new Error("Cannot complete survey. Custom housing type value is required when type is 'Other'."));
    }
  }

  next();
}

export const HouseholdModel = mongoose.model<HouseholdType & Document>(
  "Household",
  householdSchema
);
